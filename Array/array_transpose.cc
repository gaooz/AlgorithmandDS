/**
date: 2012年09月
author: gaooz.com
*/
/**********************************************************/
// 1
//-----------矩阵转置的经典算法---------
//时间复杂度为O（row*col),每个元素都要存储，相对于稀疏矩阵来说比较浪费存储空间。
for(i=0;i<row;i++)
		for(j=0;j<col;j++)
			b[j][i]=a[i][j];

/**********************************************************/
// 2
//------------------矩阵转置利用三元组实现-----------------
// 三元组的定义见：three_tuple.cc
/**
该算法时间复杂度为O(nu*tu),即与该矩阵的列数和非零元个数有关，当tu=mu*nu时，
时间复杂度为O(nu2*tu),此时的时间复杂度比一般算法的时间复杂度还要大，因此此算法适用于tu<<mu*nu的情况，此算法相比一般算法节省了存储空间。
*/
//矩阵转置，核心算法如下：
	t.mu=m.nu;t.nu=m.mu;t.tu=m.tu;
	for(i=0;i<m.nu;i++)
		for(j=0;j<m.tu;j++)//按列遍历三元组
		{
			if(m.data[j].j==i)//按列升序存入数组
			{
				t.data[p].i=m.data[j].j;
				t.data[p].j=m.data[j].i;
				t.data[p].num=m.data[j].num;
				p++;
			}
		}

/**********************************************************/
// 3
//-----------------快速转置算法<改进了时间复杂度>------------
/**
该算法时间复杂度O(nu+tu)，这种算法称为快速转置算法。
*/
t.tu=m.tu;t.mu=m.nu;t.nu=m.mu;
	for(i=1;i<=m.nu;i++)
		num[i]=0;//先使每列上元素的个数为0
	for(i=0;i<m.tu;i++)
		num[m.data[i].j]++;//遍历三元组求得每列上元素的个数
	for(i=2;i<=m.nu;i++)
		cpot[i]=cpot[i-1]+num[i-1];//求得每列上第一个元素在转置矩阵三元组中的存储序号
	for(i=0;i<m.tu;i++)
	{
		j=m.data[i].j;
		q=cpot[j];
		t.data[q].i=m.data[i].j;
		t.data[q].j=m.data[i].i;
		t.data[q].num=m.data[i].num;
		cpot[j]++;//当该列上一个元素存储完时序号加1
	}
